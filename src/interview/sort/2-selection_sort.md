---
date: 2024-02-01
category:
  - 学习
  - 前端
  - 算法
tag:
  - 算法
  - 技术深入

isOriginal: true
pageview: true
---

# **选择排序**

本篇文章从理解选择排序，到实现，再到应用场景做一个阐述。
<!-- more -->

## 1. 认识选择排序

选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理是首先在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

以下是选择排序的基本步骤：

1. 初始化：在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置。

2. 选择：从剩余未排序元素中继续寻找最小（或最大）元素。

3. 交换：找到最小（或最大）元素后，将其与未排序序列的第一个元素交换。

4. 重复：重复步骤2和3，直到所有元素都排序完毕。

选择排序的主要特点如下：

- 稳定性：选择排序是不稳定的排序方法，因为交换元素时可能会破坏相等元素的原始顺序。

- 时间复杂度：选择排序的时间复杂度为O(n^2)，其中n是待排序元素的数量。这意味着对于大型数据集，选择排序可能不是最高效的排序方法。

- 空间复杂度：选择排序的空间复杂度为O(1)，即它只需要常量级的额外空间来存储临时变量。

选择排序的优点在于其实现简单，不需要额外的数据结构来辅助排序。然而，由于其时间复杂度较高，它通常不是处理大型数据集的首选算法。在选择排序和其他排序算法之间做出选择时，应考虑数据的规模、排序的稳定性和性能要求。

![选择排序示意图](./assets/selection/1.png)

## 2. 实现选择排序

```js
function selectionSort(arr) {
  // 获取数组长度
  const len = arr.length;

  // 遍历数组，从第一个元素开始到倒数第二个元素
  for (let i = 0; i < len - 1; i++) {
    // 假设当前未排序部分的最小元素索引为i
    let minIndex = i;

    // 从当前元素的下一个位置开始，到未排序部分的末尾
    for (let j = i + 1; j < len; j++) {
      // 如果找到更小的元素，则更新最小元素索引
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }

    // 如果最小元素索引不是当前索引i，则交换它们
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }

  // 返回排序后的数组
  return arr;
}

// 示例数组
const numbers = [64, 34, 25, 12, 22, 11, 90];

// 对数组进行选择排序
const sortedNumbers = selectionSort(numbers);

// 打印排序后的数组
console.log(sortedNumbers);
```

在上面的代码中：

- selectionSort 函数接收一个数组 arr 作为参数，并返回排序后的数组。

- 外层循环 for (let i = 0; i < len - 1; i++) 遍历数组，从第一个元素开始到倒数第二个元素。因为每次循环后，当前位置及之前的元素都已经是排序好的。

- 内层循环 for (let j = i + 1; j < len; j++) 从当前元素的下一个位置开始，遍历到未排序部分的末尾，寻找最小元素的索引。

- minIndex 变量用来记录当前未排序部分最小元素的索引，初始化为外层循环的当前索引 i。

- 如果在遍历过程中发现更小的元素，则更新 minIndex。
如果 minIndex 不等于外层循环的当前索引 i，说明找到了更小的元素，需要进行交换。这里使用了ES6的解构赋值来简化交换操作。

- 最后，返回排序后的数组。

示例数组 numbers 包含了几个无序的数字，通过调用 selectionSort 函数，这些数字会被排序，并打印出排序后的结果。

选择排序的主要优点在于其实现简单，且不需要额外的存储空间（除了用于交换的临时变量）。然而，由于其时间复杂度为O(n^2)，在处理大型数据集时可能效率较低。因此，在选择排序和其他排序算法之间做出选择时，应考虑数据的规模、排序的稳定性和性能要求。

## 3. 应用场景

选择排序的使用场景主要集中在数据量较小的情况下。当需要排序的数据量非常小时，选择排序能够展现出相对高效的性能，尤其是在数据量小于5的情况下，它通常比其他排序算法都要快。

具体使用场景包括一些数据量小、对稳定性要求不高的场景，例如扑克牌游戏中的“斗牛”或“三公”等。在这些场景中，由于数据量小，选择排序能够迅速完成排序任务，同时不需要考虑过多的稳定性问题。

需要注意的是，选择排序的时间复杂度为O(n^2)，在处理大型数据集时效率较低。因此，对于数据量较大的情况，通常不推荐使用选择排序，而是应该考虑使用更高效的排序算法，如快速排序、归并排序等。

在选择排序和其他排序算法之间做出选择时，应根据数据的规模、排序的稳定性和性能要求来综合考虑。对于小型数据集，选择排序是一个简单且高效的选择；而对于大型数据集，则需要考虑更高效的算法来满足性能需求。

## 参考文章

- 图片来源：[LeetCode-JS 通关指南 - 选择排序](https://2xiao.github.io/leetcode-js/leetcode/algorithm/sort.html#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-selection-sort)